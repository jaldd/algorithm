# 排序

---

++https://github.com/jaldd/algorithm/tree/develop/datastructurealgorithm/src/main/java/org/shaotang/algorithm/sort++

---

---
衡量排序算法的优劣：
1. 时间复杂度：分析关键字的比较次数和记录的移动次数
2. 空间复杂度：分析排序算法中需要多少辅助内存
3. 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。
---
衡量排序算法的优劣：
1. 时间复杂度：分析关键字的比较次数和记录的移动次数
2. 空间复杂度：分析排序算法中需要多少辅助内存
3. 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。

## 冒泡排序（BubSort）

---
使用两重循环实现冒泡排序
- 时间复杂度：比较次数(n*n-n)/2   O（n*n）
- 空间复杂度：O(n*n)
- 算法稳定性：稳定 
---

```
public void bubbleSort() {
	long tmp=0l;
	for(int i=0;i<elems-1;i++) {
		for(int j=0;j<elems-i-1;j++) {
			if(arr[j]>arr[j+1]) {
				tmp=arr[j];
				arr[j]=arr[j+1];
				arr[j+1]=tmp;
			}
		}
	}
}
```
## 直接选择排序（SelectSort）
---
- 扫描所有元素，将最小元素与左边第一个元素交换，依次类推。
- 时间复杂度：比较次数(n*n-n)/2   O（n*n）
- 空间复杂度：O(1)
- 算法稳定性：不稳定 

---

```
public void selectSort() {
		int min=0;
		for(int i=0;i<elems-1;i++) {
			min=i;
			for(int j=i+1;j<elems;j++) {
				if(arr[j]<arr[min]) {
					min=j;
				}
			}
            if(min!=i){
			    swap(min,i);   
            }
		}
	}
```
## 插入排序

---
抽取一个元素，遍历元素找到适当位置插入

---

```
public void insertSort() {
	long select=0;
	for(int i=1;i<elems;i++) {
		select=arr[i];
		int j=0;
		for(j=i;j>0&&arr[j-1]>=select;j--) {
			arr[j]=arr[j-1];
		}
		arr[j]=select;
	}
}
```
## 堆排序（选择排序）
- 大顶堆
- 小顶堆
- 时间复杂度：n个数据需要n-1次建堆，每次消耗时间log2n
- 空间复杂度：O（1）
- 稳定性：不稳定
- 

## 直接插入排序
算法的时间效率：在最坏的情况下，所有元素的比较次数总和为（0+1+2+…+n-1）=               ；在其他情况下，也要考虑移动元素的次数，故时间复杂度为
算法的空间效率：空间效率很高，只需要一个附加程序单元用于交换，其空间效率为
算法的稳定性：稳定

## 折半插入排序
是对直接插入排序的简单改进。
此处介绍的折半插入，其实就是通过不断地折半来快速确定第i个元素的插入位置，这实际上是一种查找算法：折半查找。Java的Arrays类里的binarySearch()方法，就是折半查找的实现，用于从指定数组中查找指定元素，前提是该数组已经处于有序状态。
与直接插入排序的效果相同，只是更快了一些，因为折半插入排序可以更快地确定第i个元素的插入位置
## Shell排序
算法的时间效率：开销估计在                                       之间，平均时间复杂度大致是O(n√n)
算法的空间效率：空间效率很高，只需要一个附加程序单元用于交换，其空间效率为
算法的稳定性：不稳定 
## 桶式排序
算法的时间效率：时间效率极高，只需经过两轮遍历即可
算法的空间效率：空间开销较大，需要两个数组来完成
算法的稳定性：稳定
## 基数排序
基数排序已经不再是一种常规的排序方法，它更多地像是一种排序方法的应用，基数排序必须依赖于另外的排序方法。基数排序的总体思路就是将待排数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。
多关键字排序的思路是将待排数据里的排序关键字拆分成多个排序关键字：第1个子关键字、第2个子关键字、第3个子关键字。。。然后，根据子关键字对待排数据进行排序。
在进行多关键字排序时有两种解决方案：
最高位优先法MSD
最低位优先法LSD
## MSD法和LSD法的比较
比较MSD法和LSD法，一般来讲，LSD法要比MSD法来得简单，因为LSD法是从头到尾进行若干次分配和收集，执行的次数取决于构成关键字值的成分为多少；而MSD法则要处理各序列与子序列的独立排序问题，就可能复杂一些。
## 各种内部排序方法性能比较
1.从平均时间而言：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。
2.从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法，都包含在上图的“简单排序”中。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。
3.从稳定性看：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序
4.从待排序的记录数n的大小看，n较小时，宜采用简单排序；而n较大时宜采用改进排序。
## 排序方法的选择
(1)若n较小(如n≤50)，可采用直接插入或直接选择排序。
     当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。

(2)若文件初始状态基本有序(指正序)，则应选用直接插入、冒泡或随机的快速排序为宜；

(3)若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。


